// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider = "prisma-client-js"
}

datasource db {
    provider = "postgresql"
    // NOTE: When using mysql or sqlserver, uncomment the @db.Text annotations in model Account below
    // Further reading:
    // https://next-auth.js.org/adapters/prisma#create-the-prisma-schema
    // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#string
    url      = env("DATABASE_URL")
}

// Necessary for Next auth
model Account {
    id                       String  @id @default(cuid())
    userId                   String
    type                     String
    provider                 String
    providerAccountId        String
    refresh_token            String? // @db.Text
    access_token             String? // @db.Text
    expires_at               Int?
    token_type               String?
    scope                    String?
    id_token                 String? // @db.Text
    session_state            String?
    user                     User    @relation(fields: [userId], references: [id], onDelete: Cascade)
    refresh_token_expires_in Int?

    @@unique([provider, providerAccountId])
}

model Session {
    id           String   @id @default(cuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
    id            String    @id @default(cuid())
    name          String?
    email         String?   @unique
    emailVerified DateTime?
    image         String?
    accounts      Account[]
    sessions      Session[]
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}

// Models

// Consolidated EscapeRooms object
model EscapeRooms {
  place_id String @id @unique

  // Google data
  name                 String
  images               String[]
  rating               Float?
  reviews_count        Int?
  reviews              Json
  country              String
  city                 String
  formattedAddress     String?
  lat                  Float?
  lng                  Float?
  openingHours         Json?
  website              String?
  formattedPhoneNumber String?
  googleMapsUrl        String?

  // Crawled data
  tagline              String?
  description          String?
  price                Int? // Price level from 1 to 3
  playerCount          String?
  difficulty           String?
  atmosphere           String?
  uniqueSellingPoints  String[]
  ageRestriction       String?
  accessibility        String?
  languages            String[]
  parking              String?
  mentalDifficulty     Int?
  physicalDifficulty   Int?
  puzzleTypes          String[]
  scareFactor          Int?
  familyFriendly       Boolean?
  wheelchairAccessibleEntrance Boolean?
  categories           String[]

  minAge                     Int?
  maxAge                     Int?
  minPlayerCount             Int?
  maxPlayerCount             Int?
  terpecaAwardYears          Int[]
  isTerpecaWinner            Boolean?
  otherAwards                String?
  duration                   Int?
  bookingUrl                 String?
  cancellationPolicy         String?
  contactEmail               String?
  socialMediaLinks           Json?
  safetyMeasures             String?
  promotions                 String?
  accessibilityFeatures       String?
  locationDescription        String?
  amenities                  Json?
  photographyPolicy          String?
  merchandise                Json?
  eventHosting               Boolean?
  isScraped                  Boolean?
  
  // Add the relation to LeaderboardEntry
  leaderboardEntries LeaderboardEntry[]
  // Add the relation to Feedback
  feedback           Feedback[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
}

enum PuzzleType {
  LOGIC
  MATH
  PHYSICAL
  SEARCH
  MEMORY
  PATTERN_RECOGNITION
  RIDDLE
}

enum Category {
  HORROR
  ADVENTURE
  SCI_FI
  DETECTIVE
  HISTORICAL
  FANTASY
  ACTION
  MYSTERY
  ADULT
}

// Contact Request model for handling user inquiries
model ContactRequest {
  id          String   @id @default(uuid())
  name        String
  email       String
  subject     String
  message     String   @db.Text
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt
}

model LeaderboardEntry {
  id          String @id @default(uuid())
  place_id    String
  name        String
  email       String
  minutes     Int
  seconds     Int
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  room        EscapeRooms @relation(fields: [place_id], references: [place_id], onDelete: Cascade)

  @@index([place_id])
}

// Feedback model for storing user feedback
model Feedback {
  id          String   @id @default(uuid())
  type        FeedbackType
  message     String   @db.Text
  status      FeedbackStatus @default(PENDING)
  metadata    Json?    // Store additional context like user agent, page URL, etc.
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  // Optional relations to other models if feedback is about specific content
  escapeRoomId String? // Optional reference to an escape room
  escapeRoom   EscapeRooms? @relation(fields: [escapeRoomId], references: [place_id])

  @@index([type])
  @@index([status])
  @@index([escapeRoomId])
}

enum FeedbackType {
  POSITIVE
  NEGATIVE
}

enum FeedbackStatus {
  PENDING
  REVIEWED
  RESOLVED
  ARCHIVED
}